public static long writeFile(RGBPixel[,] ImageMatrix)
{
    int Height = GetHeight(ImageMatrix);
    int Width = GetWidth(ImageMatrix);

    //            Dictionary<int, int> redFreq = new Dictionary<int, int>();
    int[] redFreq = new int[256];
    int[] blueFreq = new int[256];
    int[] greenFreq = new int[256];

    // initializing the colors bits 0 -> 255 with frequency 0
    //            for (int i = 0; i < 256; i++)
    //                redFreq.Add(i, 0);

    // calculating the frequency of each bit
    for (int i = 0; i < Height; i++)
    {
        for (int j = 0; j < Width; j++)
        {
            redFreq[ImageMatrix[i, j].red]++;
            blueFreq[ImageMatrix[i, j].blue]++;
            greenFreq[ImageMatrix[i, j].green]++;
        }
    }


    // building the huffman tree using priority queue
    PriorityQueue pq_red = new PriorityQueue();

    // construct the priority queue with the red frequency
    for (int i = 0; i < 256; i++)
    {
        if (redFreq[i] != 0)
        {
            HuffmanNode node = new HuffmanNode
            {
                Pixel = i,
                Frequency = redFreq[i]
            };
            node.Left = node.Right = null;
            pq_red.Push(node);
        }
    }

    //construct the priority queue with the blue frequency
    PriorityQueue pq_blue = new PriorityQueue();

    for (int i = 0; i < 256; i++)
    {
        if (blueFreq[i] != 0)
        {
            HuffmanNode node = new HuffmanNode
            {
                Pixel = i,
                Frequency = blueFreq[i]
            };
            node.Left = node.Right = null;
            pq_blue.Push(node);
        }
    }

    //construct the priority queue with the green frequency
    PriorityQueue pq_green = new PriorityQueue();

    for (int i = 0; i < 256; i++)
    {
        if (greenFreq[i] != 0)
        {
            HuffmanNode node = new HuffmanNode
            {
                Pixel = i,
                Frequency = greenFreq[i]
            };
            node.Left = node.Right = null;
            pq_green.Push(node);
        }
    }


    /*            foreach (KeyValuePair<int, int> redPixel in redFreq)
                {
                    // insert the item into the priority queue and construct
                    // 256 HuffmanNode kol node shayla el pixel value (0 -> 255) w shayla el frequency bta3t el pixel de
                    // w shayla (left, right) = null

                    if (redPixel.Value != 0)
                    {
                        HuffmanNode node = new HuffmanNode
                        {
                            Pixel = redPixel.Key,
                            Frequency = redPixel.Value
                        };
                        node.Left = node.Right = null;
                        pq_red.Push(node);
                    }

                }
    */

    // construct the huffman tree for the red channel
    while (pq_red.Count != 1)
    {
        HuffmanNode node = new HuffmanNode();
        HuffmanNode smallFreq = pq_red.Pop();
        HuffmanNode largeFreq = pq_red.Pop();

        node.Frequency = smallFreq.Frequency + largeFreq.Frequency;
        node.Left = largeFreq;
        node.Right = smallFreq;
        pq_red.Push(node);
    }

    // construct the huffman tree for the blue channel
    while (pq_blue.Count != 1)
    {
        HuffmanNode node = new HuffmanNode();
        HuffmanNode smallFreq = pq_blue.Pop();
        HuffmanNode largeFreq = pq_blue.Pop();

        node.Frequency = smallFreq.Frequency + largeFreq.Frequency;
        node.Left = largeFreq;
        node.Right = smallFreq;
        pq_blue.Push(node);
    }

    // construct the huffman tree for the green channel
    while (pq_green.Count != 1)
    {
        HuffmanNode node = new HuffmanNode();
        HuffmanNode smallFreq = pq_green.Pop();
        HuffmanNode largeFreq = pq_green.Pop();

        node.Frequency = smallFreq.Frequency + largeFreq.Frequency;
        node.Left = largeFreq;
        node.Right = smallFreq;
        pq_green.Push(node);
    }


    // get the root node of the huffman tree for each channel
    HuffmanNode theRootNode = pq_red.Pop();
    HuffmanNode theRootNode2 = pq_blue.Pop();
    HuffmanNode theRootNode3 = pq_green.Pop();

    /*
    // write the initial seed and tap position to the file
    stream.WriteLine("Initial Seed: " + seedValue);
    stream.WriteLine("Tap Position: " + seedKey);

    stream.WriteLine("====================================");

    // write the huffman tree to a file with red channel
    stream.WriteLine("Red - Frequency - Huffman Representation - Total Bits");
    */

    //string s = null;

    long red_total_bits = 0;
    long green_total_bits = 0;
    long blue_total_bits = 0;

    Dictionary<int, string> red_dict = new Dictionary<int, string>();
    Dictionary<int, string> blue_dict = new Dictionary<int, string>();
    Dictionary<int, string> green_dict = new Dictionary<int, string>();

    WriteHuffmanDict(theRootNode, null, red_dict, ref red_total_bits);
    WriteHuffmanDict(theRootNode2, null, blue_dict, ref blue_total_bits);
    WriteHuffmanDict(theRootNode3, null, green_dict, ref green_total_bits);

    red_total_bits += (red_total_bits % 8);
    long red_bytes = red_total_bits / 8;
    //red_bytes += red_total_bits % 8;

    green_total_bits += (green_total_bits % 8);
    long green_bytes = green_total_bits / 8;
    //green_bytes += green_total_bits % 8;

    blue_total_bits += (blue_total_bits % 8);
    long blue_bytes = blue_total_bits / 8;
    //blue_bytes += blue_total_bits % 8;

    long total_bytes = red_bytes + blue_bytes + green_bytes;


    byte[] redBinaryRepresentationToWriteInFile = new byte[red_bytes]; //O(1) 
    byte[] blueBinaryRepresentationToWriteInFile = new byte[blue_bytes]; //O(1)
    byte[] greenBinaryRepresentationToWriteInFile = new byte[green_bytes]; //O(1)

    int byte_remainder1 = 8; //O(1)-(assignment)
    int byte_remainder2 = 8; //O(1)-(assignment)
    int byte_remainder3 = 8; //O(1)-(assignment)

    int redIndex = 0; //o(1)-(assignment)
    int blueIndex = 0; //o(1)-(assignment)
    int greenIndex = 0; //o(1)-(assignment)

    string huffman_string, rf;

    for (int i = 0; i < Height; i++) //o(h*w)
    {
        for (int j = 0; j < Width; j++) //o(w)
        {
            // red channel
            huffman_string = red_dict[ImageMatrix[i, j].red]; // temp = huffman representation of pixel 0
            if (huffman_string.Length < byte_remainder1) // if length of bits < 8 then arr[0] <<= number of bits (<8)
            {
                redBinaryRepresentationToWriteInFile[redIndex] <<= huffman_string.Length; //o(1)-(put index in array && shift)
                                                                                          // 10101, arr[idx] = 0000 0000 => 0000 0000
                redBinaryRepresentationToWriteInFile[redIndex] += Convert.ToByte(huffman_string, 2); //o(1)-(put index in array && assignment && addition && convert)
                                                                                                     // 0001 0101
                byte_remainder1 -= huffman_string.Length; //o(1)-subtraction && assignment
            }
            else if (huffman_string.Length == byte_remainder1)
            {
                // temp = "101"
                // ar = 8 - 5 = 3
                // hn shift left 00010101 f teb2a 10101000
                // "101" = 3 => arr[idx] = 10101000 => arr[idx] += "101" => 1010 1101
                redBinaryRepresentationToWriteInFile[redIndex] <<= huffman_string.Length; ////o(1)-(put index in array && shift)
                redBinaryRepresentationToWriteInFile[redIndex] += Convert.ToByte(huffman_string, 2); //o(1)-(put index in array && assignment && addition && convert)
                redIndex++; // o(1)-addition && assignment 
                byte_remainder1 = 8; //o(1)-assignment
            }
            else
            {
                rf = huffman_string.Substring(0, byte_remainder1);  //o(1) - assignment && substring
                redBinaryRepresentationToWriteInFile[redIndex] <<= byte_remainder1; //o(1)-(put index in array && shift)
                redBinaryRepresentationToWriteInFile[redIndex] += Convert.ToByte(rf, 2);  //o(1)-(put index in array && assignment && addition && convert)
                redIndex++; //o(1)-addition && assignment
                huffman_string = huffman_string.Substring(byte_remainder1, huffman_string.Length - byte_remainder1);//o(1) - assignment && substring

                while (huffman_string.Length >= 8) //o(1) AS temp size is limited to 32
                {
                    rf = huffman_string.Substring(0, 8); //o(1)-assignment && substring
                    redBinaryRepresentationToWriteInFile[redIndex] <<= 8; //o(1)-(put index in array && shift)
                    redBinaryRepresentationToWriteInFile[redIndex] += Convert.ToByte(rf, 2); //o(1)-(put index in array && assignment && addition && convert)
                    redIndex++; //o(1)-addition && assignment
                    huffman_string = huffman_string.Substring(8, huffman_string.Length - 8); //o(1) - assignment && substring
                }
                if (huffman_string.Length != 0) //o(1)
                {
                    redBinaryRepresentationToWriteInFile[redIndex] <<= huffman_string.Length; //o(1)-(put index in array && shift)
                    redBinaryRepresentationToWriteInFile[redIndex] += Convert.ToByte(huffman_string, 2); //o(1)-(put index in array && assignment && addition && convert)
                    byte_remainder1 = 8 - huffman_string.Length; // o(1) - assignment
                }
                else
                {

                    byte_remainder1 = 8; //o(1) - assignment
                }
             
            }

            //// blue channel
            //huffman_string = blue_dict[ImageMatrix[i, j].blue]; // temp = huffman representation of pixel 0
            //if (huffman_string.Length < byte_remainder2) // if length of bits < 8 then arr[0] <<= number of bits (<8)
            //{
            //    blueBinaryRepresentationToWriteInFile[blueIndex] <<= huffman_string.Length; //o(1)-(put index in array && shift)
            //                                                                                // 10101, arr[idx] = 0000 0000 => 0000 0000
            //    blueBinaryRepresentationToWriteInFile[blueIndex] += Convert.ToByte(huffman_string, 2); //o(1)-(put index in array && assignment && addition && convert)
            //                                                                                           // 0001 0101
            //    byte_remainder2 -= huffman_string.Length; //o(1)-subtraction && assignment
            //}
            //else if (huffman_string.Length == byte_remainder2)
            //{
            //    // temp = "101"
            //    // ar = 8 - 5 = 3
            //    // hn shift left 00010101 f teb2a 10101000
            //    // "101" = 3 => arr[idx] = 10101000 => arr[idx] += "101" => 1010 1101
            //    blueBinaryRepresentationToWriteInFile[blueIndex] <<= huffman_string.Length; ////o(1)-(put index in array && shift)
            //    blueBinaryRepresentationToWriteInFile[blueIndex] += Convert.ToByte(huffman_string, 2); //o(1)-(put index in array && assignment && addition && convert)
            //    blueIndex++; // o(1)-addition && assignment 
            //    byte_remainder2 = 8; //o(1)-assignment
            //}
            //else
            //{
            //    rf = huffman_string.Substring(0, byte_remainder2); //o(1) - assignment && substring
            //    blueBinaryRepresentationToWriteInFile[blueIndex] <<= byte_remainder2; //o(1)-(put index in array && shift)
            //    blueBinaryRepresentationToWriteInFile[blueIndex] += Convert.ToByte(rf, 2);  //o(1)-(put index in array && assignment && addition && convert)
            //    blueIndex++; //o(1)-addition && assignment
            //    huffman_string = huffman_string.Substring(byte_remainder2, huffman_string.Length - byte_remainder2);//o(1) - assignment && substring

            //    while (huffman_string.Length >= 8) //o(1) AS temp size is limited to 32
            //    {
            //        rf = huffman_string.Substring(0, 8); //o(1)-assignment && substring
            //        blueBinaryRepresentationToWriteInFile[blueIndex] <<= 8; //o(1)-(put index in array && shift)
            //        blueBinaryRepresentationToWriteInFile[blueIndex] += Convert.ToByte(rf, 2); //o(1)-(put index in array && assignment && addition && convert)
            //        blueIndex++; //o(1)-addition && assignment
            //        huffman_string = huffman_string.Substring(8, huffman_string.Length - 8); //o(1) - assignment && substring
            //    }
            //    if (huffman_string.Length != 0) //o(1)
            //    {
            //        blueBinaryRepresentationToWriteInFile[blueIndex] <<= huffman_string.Length; //o(1)-(put index in array && shift)
            //        blueBinaryRepresentationToWriteInFile[blueIndex] += Convert.ToByte(huffman_string, 2); //o(1)-(put index in array && assignment && addition && convert)
            //        byte_remainder2 = 8 - huffman_string.Length; // o(1) - assignment
            //    }
            //    else
            //        byte_remainder2 = 8; //o(1) - assignment
            //}

            //// green channel
            //huffman_string = green_dict[ImageMatrix[i, j].green]; // temp = huffman representation of pixel 0
            //if (huffman_string.Length < byte_remainder3) // if length of bits < 8 then arr[0] <<= number of bits (<8)
            //{
            //    greenBinaryRepresentationToWriteInFile[greenIndex] <<= huffman_string.Length; //o(1)-(put index in array && shift)
            //                                                                                  // 10101, arr[idx] = 0000 0000 => 0000 0000
            //    greenBinaryRepresentationToWriteInFile[greenIndex] += Convert.ToByte(huffman_string, 2); //o(1)-(put index in array && assignment && addition && convert)
            //                                                                                             // 0001 0101
            //    byte_remainder3 -= huffman_string.Length; //o(1)-subtraction && assignment
            //}
            //else if (huffman_string.Length == byte_remainder3)
            //{
            //    // temp = "101"
            //    // ar = 8 - 5 = 3
            //    // hn shift left 00010101 f teb2a 10101000
            //    // "101" = 3 => arr[idx] = 10101000 => arr[idx] += "101" => 1010 1101
            //    greenBinaryRepresentationToWriteInFile[greenIndex] <<= huffman_string.Length; ////o(1)-(put index in array && shift)
            //    greenBinaryRepresentationToWriteInFile[greenIndex] += Convert.ToByte(huffman_string, 2); //o(1)-(put index in array && assignment && addition && convert)
            //    greenIndex++; // o(1)-addition && assignment 
            //    byte_remainder3 = 8; //o(1)-assignment
            //}
            //else
            //{
            //    rf = huffman_string.Substring(0, byte_remainder3); //o(1) - assignment && substring
            //    greenBinaryRepresentationToWriteInFile[greenIndex] <<= byte_remainder3; //o(1)-(put index in array && shift)
            //    greenBinaryRepresentationToWriteInFile[greenIndex] += Convert.ToByte(rf, 2);  //o(1)-(put index in array && assignment && addition && convert)
            //    greenIndex++; //o(1)-addition && assignment
            //    huffman_string = huffman_string.Substring(byte_remainder3, huffman_string.Length - byte_remainder3);//o(1) - assignment && substring

            //    while (huffman_string.Length >= 8) //o(1) AS temp size is limited to 32
            //    {
            //        rf = huffman_string.Substring(0, 8); //o(1)-assignment && substring
            //        greenBinaryRepresentationToWriteInFile[greenIndex] <<= 8; //o(1)-(put index in array && shift)
            //        greenBinaryRepresentationToWriteInFile[greenIndex] += Convert.ToByte(rf, 2); //o(1)-(put index in array && assignment && addition && convert)
            //        greenIndex++; //o(1)-addition && assignment
            //        huffman_string = huffman_string.Substring(8, huffman_string.Length - 8); //o(1) - assignment && substring
            //    }

            //    if (huffman_string.Length != 0) //o(1)
            //    {
            //        greenBinaryRepresentationToWriteInFile[greenIndex] <<= huffman_string.Length; //o(1)-(put index in array && shift)
            //        greenBinaryRepresentationToWriteInFile[greenIndex] += Convert.ToByte(huffman_string, 2); //o(1)-(put index in array && assignment && addition && convert)
            //        byte_remainder3 = 8 - huffman_string.Length; // o(1) - assignment
            //    }
            //    else { 
            //        byte_remainder3 = 8; //o(1) - assignment
            //    }
            //}

        }
    }

    //                byte[] redd = new byte[1024]; //o(1) (assignment)
    //                    for (int i = 0; i < 256; i++)
    //                      Array.Copy(BitConverter.GetBytes(redFreq[i]), 0, redd, i * 4, 4);//o(nlon)(number of iterations*4 && copy to array)


    //                    FileStream ffs = new FileStream("com.txt", FileMode.Truncate);
    //                    StreamWriter ffss = new StreamWriter(ffs);
    //                    ffss.WriteLine(red_com.Length);//o(1) (write in file)
    //                  ffss.Close();
    //        ffs.Close();

    FileStream ss = new FileStream(BinaryPath, FileMode.Truncate);
    BinaryWriter binWriter = new BinaryWriter(ss);
    //                    binWriter.Write(redd);//o(1) (write in file)

    binWriter.Write(redBinaryRepresentationToWriteInFile);//o(1) (write in file)
    binWriter.Write(blueBinaryRepresentationToWriteInFile);//o(1) (write in file)
    binWriter.Write(greenBinaryRepresentationToWriteInFile);//o(1) (write in file)  

    //                    binWriter.Write(seed);//o(1) (write in file)

    //                    binWriter.Write(tape);//o(1) (write in file)

    //                    binWriter.Write(Width);//o(1) (write in file)
    //                    binWriter.Write(Height);//o(1) (write in file)

    binWriter.Close();
    ss.Close();

    return total_bytes;
}

===================================

        // function to compress the image using the huffman algorithm
        public static long CompressImage(RGBPixel[,] ImageMatrix, int tapPosition, string seedValue)
        {
            // get the height and width of the image
            int Height = GetHeight(ImageMatrix);
            int Width = GetWidth(ImageMatrix);

            // initializing the frequency of each color bit
            int[] redFreq = new int[256];
            int[] blueFreq = new int[256];
            int[] greenFreq = new int[256];

            // calculate the frequency of each color bit
            for (int i = 0; i < Height; i++)
            {
                for (int j = 0; j < Width; j++)
                {
                    redFreq[ImageMatrix[i, j].red]++;
                    blueFreq[ImageMatrix[i, j].blue]++;
                    greenFreq[ImageMatrix[i, j].green]++;
                }
            }


            // construct the priority queue with the red frequency
            PriorityQueue pq_red = new PriorityQueue();

            // iterate over the red frequency array and insert the non-zero frequencies into the priority queue
            for (int i = 0; i < 256; i++)
            {
                if (redFreq[i] != 0)
                {
                    HuffmanNode node = new HuffmanNode
                    {
                        Pixel = i,
                        Frequency = redFreq[i]
                    };
                    node.Left = node.Right = null;
                    pq_red.Push(node);
                }
            }

            //construct the priority queue with the blue frequency
            PriorityQueue pq_blue = new PriorityQueue();

            // iterate over the blue frequency array and insert the non-zero frequencies into the priority queue
            for (int i = 0; i < 256; i++)
            {
                if (blueFreq[i] != 0)
                {
                    HuffmanNode node = new HuffmanNode
                    {
                        Pixel = i,
                        Frequency = blueFreq[i]
                    };
                    node.Left = node.Right = null;
                    pq_blue.Push(node);
                }
            }

            //construct the priority queue with the green frequency
            PriorityQueue pq_green = new PriorityQueue();

            // iterate over the green frequency array and insert the non-zero frequencies into the priority queue
            for (int i = 0; i < 256; i++)
            {
                if (greenFreq[i] != 0)
                {
                    HuffmanNode node = new HuffmanNode
                    {
                        Pixel = i,
                        Frequency = greenFreq[i]
                    };
                    node.Left = node.Right = null;
                    pq_green.Push(node);
                }
            }

            // construct the huffman tree for the red channel
            while (pq_red.Count != 1)
            {
                HuffmanNode node = new HuffmanNode();
                HuffmanNode smallFreq = pq_red.Pop();
                HuffmanNode largeFreq = pq_red.Pop();

                node.Frequency = smallFreq.Frequency + largeFreq.Frequency;
                node.Left = largeFreq;
                node.Right = smallFreq;
                pq_red.Push(node);
            }

            // construct the huffman tree for the blue channel
            while (pq_blue.Count != 1)
            {
                HuffmanNode node = new HuffmanNode();
                HuffmanNode smallFreq = pq_blue.Pop();
                HuffmanNode largeFreq = pq_blue.Pop();

                node.Frequency = smallFreq.Frequency + largeFreq.Frequency;
                node.Left = largeFreq;
                node.Right = smallFreq;
                pq_blue.Push(node);
            }

            // construct the huffman tree for the green channel
            while (pq_green.Count != 1)
            {
                HuffmanNode node = new HuffmanNode();
                HuffmanNode smallFreq = pq_green.Pop();
                HuffmanNode largeFreq = pq_green.Pop();

                node.Frequency = smallFreq.Frequency + largeFreq.Frequency;
                node.Left = largeFreq;
                node.Right = smallFreq;
                pq_green.Push(node);
            }

            // get the root node of the huffman tree for each channel
            HuffmanNode theRootNode = pq_red.Pop();
            HuffmanNode theRootNode2 = pq_blue.Pop();
            HuffmanNode theRootNode3 = pq_green.Pop();

            long red_total_bits = 0;
            long green_total_bits = 0;
            long blue_total_bits = 0;

            // create dictionaries to store the huffman representation of each color bit
            Dictionary<int, string> red_dict = new Dictionary<int, string>();
            Dictionary<int, string> blue_dict = new Dictionary<int, string>();
            Dictionary<int, string> green_dict = new Dictionary<int, string>();

            // create a stream writer to write the huffman tree to a file
            StreamWriter stream = new StreamWriter(CompressionPath);

            // write the initial seed and tap position to the file
            stream.WriteLine("Initial Seed: " + seedValue);
            stream.WriteLine("Tap Position: " + tapPosition);

            // write the huffman tree to a file with red channel
            stream.WriteLine("Red - Frequency - Huffman Representation - Total Bits");
            WriteHuffmanDict(theRootNode, null, red_dict, ref red_total_bits, stream);

            // write the huffman tree to a file with blue channel
            stream.WriteLine("Blue - Frequency - Huffman Representation - Total Bits");
            WriteHuffmanDict(theRootNode2, null, blue_dict, ref blue_total_bits, stream);

            // write the huffman tree to a file with green channel
            stream.WriteLine("Green - Frequency - Huffman Representation - Total Bits");
            WriteHuffmanDict(theRootNode3, null, green_dict, ref green_total_bits, stream);

            // calculate the total bytes of the image for each channel

            // red channel
            red_total_bits += (red_total_bits % 8);
            long red_bytes = red_total_bits / 8;

            // green channel
            green_total_bits += (green_total_bits % 8);
            long green_bytes = green_total_bits / 8;

            // blue channel
            blue_total_bits += (blue_total_bits % 8);
            long blue_bytes = blue_total_bits / 8;

            // calculate the total bytes of the image
            long total_bytes = red_bytes + blue_bytes + green_bytes;

            // write the total bytes of the image
            stream.WriteLine("Total Bytes: " + total_bytes);

            // write the compression ratio of the image
            long total_bits = red_total_bits + blue_total_bits + green_total_bits;
            long image_size = Height * Width * 24; // product by 24 for the 3 channels (red, green, blue) and each channel has 8 bits (1 byte)
            double compression_ratio = (double)total_bits / image_size;
            stream.WriteLine("Compression Ratio: " + compression_ratio * 100 + "%");

            // close the stream writer
            stream.Close();

            // byte array to store the binary representation of the image of size total_bytes for each channel
            byte[] redBinaryRepresentationToWriteInFile = new byte[red_bytes];
            byte[] blueBinaryRepresentationToWriteInFile = new byte[blue_bytes];
            byte[] greenBinaryRepresentationToWriteInFile = new byte[green_bytes];

            // variables to store the remaining bits in the byte
            int byte_remainder1 = 8; //O(1)-(assignment)
            int byte_remainder2 = 8; //O(1)-(assignment)
            int byte_remainder3 = 8; //O(1)-(assignment)

            // variables to store the index of the byte array
            int redIndex = 0; //o(1)-(assignment)
            int blueIndex = 0; //o(1)-(assignment)
            int greenIndex = 0; //o(1)-(assignment)

            // variables to store the huffman representation of the pixel
            string huffman_string, rf;

            for (int i = 0; i < Height; i++) //o(h*w)
            {
                for (int j = 0; j < Width; j++) //o(w)
                {
                    // red channel

                    // get the huffman representation of the pixel
                    huffman_string = red_dict[ImageMatrix[i, j].red]; // temp = huffman representation of pixel 0

                    // if the length of the huffman representation is less than the remaining bits in the byte
                    if (huffman_string.Length < byte_remainder1)
                    {
                        redBinaryRepresentationToWriteInFile[redIndex] <<= huffman_string.Length; //o(1)-(put index in array && shift)
                                                                                                  // 10101, arr[idx] = 0000 0000 => 0000 0000
                        redBinaryRepresentationToWriteInFile[redIndex] += Convert.ToByte(huffman_string, 2); //o(1)-(put index in array && assignment && addition && convert)
                                                                                                             // 0001 0101
                        byte_remainder1 -= huffman_string.Length; //o(1)-subtraction && assignment
                    }
                    else if (huffman_string.Length == byte_remainder1)
                    {
                        // temp = "101"
                        // ar = 8 - 5 = 3
                        // hn shift left 00010101 f teb2a 10101000
                        // "101" = 3 => arr[idx] = 10101000 => arr[idx] += "101" => 1010 1101
                        redBinaryRepresentationToWriteInFile[redIndex] <<= huffman_string.Length; ////o(1)-(put index in array && shift)
                        redBinaryRepresentationToWriteInFile[redIndex] += Convert.ToByte(huffman_string, 2); //o(1)-(put index in array && assignment && addition && convert)
                        redIndex++; // o(1)-addition && assignment 
                        byte_remainder1 = 8; //o(1)-assignment
                    }
                    else
                    {
                        rf = huffman_string.Substring(0, byte_remainder1);  //o(1) - assignment && substring
                        redBinaryRepresentationToWriteInFile[redIndex] <<= byte_remainder1; //o(1)-(put index in array && shift)
                        redBinaryRepresentationToWriteInFile[redIndex] += Convert.ToByte(rf, 2);  //o(1)-(put index in array && assignment && addition && convert)
                        redIndex++; //o(1)-addition && assignment
                        huffman_string = huffman_string.Substring(byte_remainder1, huffman_string.Length - byte_remainder1);//o(1) - assignment && substring

                        while (huffman_string.Length >= 8) //o(1) AS temp size is limited to 32
                        {
                            rf = huffman_string.Substring(0, 8); //o(1)-assignment && substring
                            redBinaryRepresentationToWriteInFile[redIndex] <<= 8; //o(1)-(put index in array && shift)
                            redBinaryRepresentationToWriteInFile[redIndex] += Convert.ToByte(rf, 2); //o(1)-(put index in array && assignment && addition && convert)
                            redIndex++; //o(1)-addition && assignment
                            huffman_string = huffman_string.Substring(8, huffman_string.Length - 8); //o(1) - assignment && substring
                        }
                        if (huffman_string.Length != 0) //o(1)
                        {
                            redBinaryRepresentationToWriteInFile[redIndex] <<= huffman_string.Length; //o(1)-(put index in array && shift)
                            redBinaryRepresentationToWriteInFile[redIndex] += Convert.ToByte(huffman_string, 2); //o(1)-(put index in array && assignment && addition && convert)
                            byte_remainder1 = 8 - huffman_string.Length; // o(1) - assignment
                        }
                        else
                        {

                            byte_remainder1 = 8; //o(1) - assignment
                        }

                    }

                    // blue channel
                    huffman_string = blue_dict[ImageMatrix[i, j].blue]; // temp = huffman representation of pixel 0
                    if (huffman_string.Length < byte_remainder2) // if length of bits < 8 then arr[0] <<= number of bits (<8)
                    {
                        blueBinaryRepresentationToWriteInFile[blueIndex] <<= huffman_string.Length; //o(1)-(put index in array && shift)
                                                                                                    // 10101, arr[idx] = 0000 0000 => 0000 0000
                        blueBinaryRepresentationToWriteInFile[blueIndex] += Convert.ToByte(huffman_string, 2); //o(1)-(put index in array && assignment && addition && convert)
                                                                                                               // 0001 0101
                        byte_remainder2 -= huffman_string.Length; //o(1)-subtraction && assignment
                    }
                    else if (huffman_string.Length == byte_remainder2)
                    {
                        // temp = "101"
                        // ar = 8 - 5 = 3
                        // hn shift left 00010101 f teb2a 10101000
                        // "101" = 3 => arr[idx] = 10101000 => arr[idx] += "101" => 1010 1101
                        blueBinaryRepresentationToWriteInFile[blueIndex] <<= huffman_string.Length; ////o(1)-(put index in array && shift)
                        blueBinaryRepresentationToWriteInFile[blueIndex] += Convert.ToByte(huffman_string, 2); //o(1)-(put index in array && assignment && addition && convert)
                        blueIndex++; // o(1)-addition && assignment 
                        byte_remainder2 = 8; //o(1)-assignment
                    }
                    else
                    {
                        rf = huffman_string.Substring(0, byte_remainder2); //o(1) - assignment && substring
                        blueBinaryRepresentationToWriteInFile[blueIndex] <<= byte_remainder2; //o(1)-(put index in array && shift)
                        blueBinaryRepresentationToWriteInFile[blueIndex] += Convert.ToByte(rf, 2);  //o(1)-(put index in array && assignment && addition && convert)
                        blueIndex++; //o(1)-addition && assignment
                        huffman_string = huffman_string.Substring(byte_remainder2, huffman_string.Length - byte_remainder2);//o(1) - assignment && substring

                        while (huffman_string.Length >= 8) //o(1) AS temp size is limited to 32
                        {
                            rf = huffman_string.Substring(0, 8); //o(1)-assignment && substring
                            blueBinaryRepresentationToWriteInFile[blueIndex] <<= 8; //o(1)-(put index in array && shift)
                            blueBinaryRepresentationToWriteInFile[blueIndex] += Convert.ToByte(rf, 2); //o(1)-(put index in array && assignment && addition && convert)
                            blueIndex++; //o(1)-addition && assignment
                            huffman_string = huffman_string.Substring(8, huffman_string.Length - 8); //o(1) - assignment && substring
                        }
                        if (huffman_string.Length != 0) //o(1)
                        {
                            blueBinaryRepresentationToWriteInFile[blueIndex] <<= huffman_string.Length; //o(1)-(put index in array && shift)
                            blueBinaryRepresentationToWriteInFile[blueIndex] += Convert.ToByte(huffman_string, 2); //o(1)-(put index in array && assignment && addition && convert)
                            byte_remainder2 = 8 - huffman_string.Length; // o(1) - assignment
                        }
                        else
                            byte_remainder2 = 8; //o(1) - assignment
                    }

                    // green channel
                    huffman_string = green_dict[ImageMatrix[i, j].green]; // temp = huffman representation of pixel 0
                    if (huffman_string.Length < byte_remainder3) // if length of bits < 8 then arr[0] <<= number of bits (<8)
                    {
                        greenBinaryRepresentationToWriteInFile[greenIndex] <<= huffman_string.Length; //o(1)-(put index in array && shift)
                                                                                                      // 10101, arr[idx] = 0000 0000 => 0000 0000
                        greenBinaryRepresentationToWriteInFile[greenIndex] += Convert.ToByte(huffman_string, 2); //o(1)-(put index in array && assignment && addition && convert)
                                                                                                                 // 0001 0101
                        byte_remainder3 -= huffman_string.Length; //o(1)-subtraction && assignment
                    }
                    else if (huffman_string.Length == byte_remainder3)
                    {
                        // temp = "101"
                        // ar = 8 - 5 = 3
                        // hn shift left 00010101 f teb2a 10101000
                        // "101" = 3 => arr[idx] = 10101000 => arr[idx] += "101" => 1010 1101
                        greenBinaryRepresentationToWriteInFile[greenIndex] <<= huffman_string.Length; ////o(1)-(put index in array && shift)
                        greenBinaryRepresentationToWriteInFile[greenIndex] += Convert.ToByte(huffman_string, 2); //o(1)-(put index in array && assignment && addition && convert)
                        greenIndex++; // o(1)-addition && assignment 
                        byte_remainder3 = 8; //o(1)-assignment
                    }
                    else
                    {
                        rf = huffman_string.Substring(0, byte_remainder3); //o(1) - assignment && substring
                        greenBinaryRepresentationToWriteInFile[greenIndex] <<= byte_remainder3; //o(1)-(put index in array && shift)
                        greenBinaryRepresentationToWriteInFile[greenIndex] += Convert.ToByte(rf, 2);  //o(1)-(put index in array && assignment && addition && convert)
                        greenIndex++; //o(1)-addition && assignment
                        huffman_string = huffman_string.Substring(byte_remainder3, huffman_string.Length - byte_remainder3);//o(1) - assignment && substring

                        while (huffman_string.Length >= 8) //o(1) AS temp size is limited to 32
                        {
                            rf = huffman_string.Substring(0, 8); //o(1)-assignment && substring
                            greenBinaryRepresentationToWriteInFile[greenIndex] <<= 8; //o(1)-(put index in array && shift)
                            greenBinaryRepresentationToWriteInFile[greenIndex] += Convert.ToByte(rf, 2); //o(1)-(put index in array && assignment && addition && convert)
                            greenIndex++; //o(1)-addition && assignment
                            huffman_string = huffman_string.Substring(8, huffman_string.Length - 8); //o(1) - assignment && substring
                        }

                        if (huffman_string.Length != 0) //o(1)
                        {
                            greenBinaryRepresentationToWriteInFile[greenIndex] <<= huffman_string.Length; //o(1)-(put index in array && shift)
                            greenBinaryRepresentationToWriteInFile[greenIndex] += Convert.ToByte(huffman_string, 2); //o(1)-(put index in array && assignment && addition && convert)
                            byte_remainder3 = 8 - huffman_string.Length; // o(1) - assignment
                        }
                        else
                        {
                            byte_remainder3 = 8; //o(1) - assignment
                        }
                    }

                }
            }

            FileStream ss = new FileStream(BinaryPath, FileMode.Truncate);
            BinaryWriter binWriter = new BinaryWriter(ss);

            binWriter.Write(redBinaryRepresentationToWriteInFile);//o(1) (write in file)
            binWriter.Write(blueBinaryRepresentationToWriteInFile);//o(1) (write in file)
            binWriter.Write(greenBinaryRepresentationToWriteInFile);//o(1) (write in file)  

            binWriter.Close();
            ss.Close();

            return total_bytes;
        }
